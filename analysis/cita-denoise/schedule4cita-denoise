#!/usr/bin/env python3

"""a quick script to schedule workflows
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os
import stat

from argparse import ArgumentParser

#-------------------------------------------------

SCALARS = ["dens"]

VECTORS = ["mag", "vel", "curr", "vort"]

DIRECTIONS = [None, 0, 1, 2]

COMPONENTS = [None] # , 0, 1, 2]
MAP2SCALARS = [('' if component is None else '_%d'%component, dict(component=component)) for component in COMPONENTS]
#MAP2SCALARS += [('_mag', dict(magnitude=True))]

DIRECTS = [True, False]

#------------------------

SMOOTHS = [True, False]

THRESHOLDS = [1, 2, 3, 4, 5, 10] # , 15, 20]

#------------------------

MARKERS = ['o', '^', 's', 'D', 'p', '>', '<', 'v']

#-------------------------------------------------

def sf_nickname(thr, smooth=False, field=None, magnitude=False, component=None, direction=None, direct=False):
    assert field is not None

    tag = field

    if magnitude:
        tag = tag+'-mag'

    elif component is not None:
        tag = tag+'-%d'%component

    if direction is not None:
        tag = tag+'_dir-%d' % direction

    if direct:
        tag += '_dsf'
    else:
        tag += '_wsf'

    tag = tag + ('_denoise-%s' % thr)

    if smooth:
        tag = tag+'-smooth'

    return tag

#---

def sf_outpath(base, thr, smooth=False, field=None, magnitude=False, component=None, direction=None, direct=False, outdir='.'):
    nickname = sf_nickname(
        thr,
        smooth=smooth,
        field=field,
        magnitude=magnitude,
        component=component,
        direction=direction,
        direct=direct,
    )
    return os.path.join(os.path.abspath(outdir), '%s_%s.hdf' % (base, nickname))

#------------------------

def sf_cmds(
        inpath,
        index,
        base,
        field,
        thrs,
        commands,
        max_edgelength=None,
        direct_increment=None,
        flash=False,
        outdir='.',
        verbose=True,
        copy=False,
    ):

    # a list of commands
    cmd_strs = []

    #---

    if copy:
        # get a local copy of HDf file
        newpath = '/mnt/node_scratch/essick/%s_%s.hdf' % (base, field)
        cmd_strs.append('echo "copying data locally to: %s"\ncp \\\n    %s \\\n    %s \\\n|| exit 1' % \
            (newpath, inpath, newpath))

    else:
        newpath = inpath

    #---

    # set up iteration over thrs, commands
    cmd_str = 'for THR in %s' % (' '.join(['%02d'%_ for _ in thrs]))
    cmd_str += '\ndo'

    for cmd in commands:

        cmd_str += '\n\n'

        # add logic to check whether output file already exists
        o = sf_outpath(
            base,
            '${THR}',
            field=field,
            outdir=outdir,
            **cmd
        )

        cmd_str += 'if [ ! -f  %s ]\nthen\n    ' % o

        c = sf_cmd(
            newpath,
            index,
            base,
            '${THR}',
            field=field,
            max_edgelength=max_edgelength,
            direct_increment=direct_increment,
            flash=flash,
            outdir=outdir,
            verbose=verbose,
            **cmd
        )
        cmd_str +=' \\\n        '.join(c)

        cmd_str += ' \\\n|| exit 1'

        cmd_str += '\nelse\n    echo "%s already exists...skipping"\nfi' % o

    cmd_str += '\n\ndone'

    cmd_strs.append(cmd_str)

    #---

    if copy: # remove local copy
        cmd_strs.append('echo "removing local copy from: %s"\nrm %s' % (newpath, newpath))

    #---

    script = os.path.join(outdir, 'sf-%s_%s.sh' % (base, field))

    #---

    # return
    return cmd_strs, script

#---

def sf_cmd(
        inpath,
        index,
        base,
        thr,
        smooth=False,
        max_scale=None,
        field=None,
        component=None,
        magnitude=False,
        direction=None,
        direct=False,
        flash=False,
        verbose=True,
        max_edgelength=None,
        direct_increment=None,
        outdir='.',
    ):

    assert field is not None

    outpath = sf_outpath(
        base,
        thr,
        smooth=smooth,
        field=field,
        magnitude=magnitude,
        component=component,
        direction=direction,
        direct=direct,
        outdir=outdir,
    )
    script = outpath[:-3] + 'sh'

    cmd = ['w4t-structure-function', inpath, outpath, field]

    cmd += ['--index %s' % (' '.join('%d'%_ for _ in index))]

    cmd += ['--threshold %s' % thr]

    if smooth:
        cmd += ['--smooth']

    if max_scale:
        cmd += ['--max-scale %.6f' % max_scale]

    if flash:
        cmd += ['--flash']

    if verbose:
        cmd += ['--Verbose']

    if max_edgelength is not None:
        cmd += ['--max-edgelength %d' % max_edgelength]

    if direct_increment is not None:
        cmd += ['--direct-increment %d' % direct_increment]

    if magnitude:
        cmd += ['--magnitude']

    elif component is not None:
        cmd += ['--component %d' % component]

    if direction is not None:
        cmd += ['--direction %d' % direction]

    if direct:
        cmd += ['--direct']

    return cmd

#------------------------

def write_script(path, cmd_strs, verbose=False, **notes):
    if verbose:
        print('    writing: '+path)

    with open(path, 'w') as obj:
        obj.write('#!/bin/bash -l')

        # add material for PBS
        obj.write('\n#PBS -l nodes=1:ppn=1')
        obj.write('\n#PBS -l walltime=48:00:00')
        obj.write('\n#PBS -q workq')
        obj.write('\n#PBS -r n') # not re-runnable

        obj.write('\n#PBS -o %s' % (path[:-2]+'out'))
        obj.write('\n#PBS -e %s' % (path[:-2]+'err'))

        # add other notes
        if len(notes):
            obj.write('\n')
            for key, val in notes.items():
                obj.write('\n# %s : %s' % (key, val))

        # load modules?
#        module load gcc/7.3.0 python/2.7.14

        # add actual commands
        for cmd_str in cmd_strs:
            obj.write('\n\n#---')
            obj.write('\n\n%s' % cmd_str)

        obj.write('\n')

    # change script to be executable
    os.chmod(path, os.stat(path).st_mode | stat.S_IEXEC)

    # return
    return os.path.abspath(path)

#------------------------

def write_workflow(path, scripts, verbose=False, **notes):
    if verbose:
        print('    writing: '+path)

    with open(path, 'w') as obj:
        obj.write('#!/bin/bash')

        if len(notes):
            obj.write('\n')
            for key, val in notes.items():
                obj.write('\n# %s : %s' % (key, val))

        obj.write('\n')
        for s in scripts:
            obj.write('\n%s || exit 1' % s)

    os.chmod(path, os.stat(path).st_mode | stat.S_IEXEC)

    return os.path.abspath(path)

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('inpath', type=str)
parser.add_argument('flow', type=str)
parser.add_argument('snap', type=int)

parser.add_argument('--flash', default=False, action='store_true')

parser.add_argument('-o', '--output-dir', default='.', type=str)
#parser.add_argument('-d', '--data-dir', default='.', type=str)

parser.add_argument('--max-edgelength', default=None, type=int)
parser.add_argument('--index', nargs='*', type=int, default=[1, 2, 3, 4, 5, 6])

parser.add_argument('--direct-increment', default=None, type=int)

parser.add_argument('--copy', default=False, action='store_true')

parser.add_argument('-v', '--verbose', default=False, action='store_true')
parser.add_argument('-V', '--Verbose', default=False, action='store_true')

args = parser.parse_args()

os.makedirs(args.output_dir, exist_ok=True)

args.verbose |= args.Verbose

#-------------------------------------------------

base = '%s_%04d' % (args.flow, args.snap)
#inpath = os.path.join(os.path.abspath(args.data_dir), base+'.hdf')

#------------------------

# schedule jobs that compute structure functions

commands = dict()

# add different fields
for field in SCALARS:
    commands[field] = [dict()] # default map2scalar: the field's value

for field in VECTORS:
    commands[field] = [dict(**map2scalar) for _, map2scalar in MAP2SCALARS]

#---

# add different methods for computing structure function
for field in commands.keys():
    commands[field] = [dict(direct=direct, **cmd) for direct in DIRECTS for cmd in commands[field]]

#-----------

# add options to process with smoothing instead of denoising
for field in commands.keys():
    commands[field] = [dict(smooth=smooth, **cmd) for smooth in SMOOTHS for cmd in commands[field]]

#------------------------

if args.verbose:
    print('writing individual structure function jobs')

scripts = []
for field in commands.keys():

    cmd_strs, script = sf_cmds(
        args.inpath,
        args.index,
        base,
        field,
        THRESHOLDS,
        commands=commands[field],
        flash=args.flash,
        verbose=args.verbose,
        max_edgelength=args.max_edgelength,
        direct_increment=args.direct_increment,
        copy=args.copy,
        outdir=args.output_dir,
    )

    scripts.append(write_script(script, cmd_strs, verbose=args.Verbose, base=base))

#---

if args.verbose:
    print('writing overall workflow')

write_workflow(
    os.path.join(args.output_dir, 'sf-%s.sh' % base),
    scripts,
    verbose=args.verbose,
    base=base,
)
